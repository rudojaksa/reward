#!/usr/bin/perl
# Copyleft: R.Jaksa 2018, GNU General Public License version 3
# ------------------------------------------------------------------------- SUPPORT

# colors
$CR_="\033[31m"; # color red
$CG_="\033[32m"; # color green
$CY_="\033[33m"; # color yellow
$CB_="\033[34m"; # color blue
$CM_="\033[35m"; # color magenta
$CC_="\033[36m"; # color cyan
$CW_="\033[37m"; # color white
$CK_="\033[90m"; # color black
$CP_="\033[91m"; # color pink
$CL_="\033[92m"; # color lime
$CS_="\033[93m"; # color sulphur yellow
$CZ_="\033[94m"; # color azure
$CO_="\033[95m"; # color orchid
$CA_="\033[96m"; # color aqua cyan
$CF_="\033[97m"; # color fluorescent white
$CD_="\033[0m";  # color default

# inar(\@a,$s) - check whether the string is in the array
sub inar {
  my $a=$_[0]; # array ref
  my $s=$_[1]; # string
  foreach(@{$a}) { return 1 if $_ eq $s; }
  return 0; }

# --------------------------------------------------------------------------- ARGVS

our $INPUT = $ARGV[0];

die "not a file \"$INPUT\"" if not -f $INPUT;

# --------------------------------------------------------------------------- INPUT

$RAW = `cat $INPUT`;

# ------------------------------------------------------------------- PREPROCESSING

# remove color escape sequences
$RAW =~ s/\033\[36m//g;	# cyan
$RAW =~ s/\033\[37m//g;	# white
$RAW =~ s/\033\[90m//g;	# black
$RAW =~ s/\033\[0m//g;	# default

# titles
$RAW =~ s/\n([A-Z])/\n\#\#\# $1/g;
$RAW =~ s/\n([A-Za-z0-9-]+(\h+[A-Za-z0-9-]+)?(\h+[A-Za-z0-9-]+)?:)/\n\#\#\#\# $1/g;

# multiple newlines
$RAW =~ s/\n\h*\n\h*(\n\h*)+/\n\n/g;

# ------------------------------------------------------------------ SPLIT SECTIONS

# split into sections
our @HEAD; # header text
our %HDPX; # header prefix
our %BODY; # section body
sub addsec { push @HEAD,$_[0]; $HDPX{$_[0]} = $_[1]; $BODY{$_[0]} = $_[2]; }

my $head; # current header
my $hdpx; # header prefix
my $body; # current body
foreach my $s (split /\n/,$RAW) {

  # header => store past section
  if($s =~ /^(\#\#*) (.*)\h*$/) {
    addsec $head,$hdpx,$body and undef $body if defined $head and defined $body;
    $head = $2;
    $hdpx = $1; }

  # just line
  else {
    $body .= "$s\n" if defined $head; }} # store the body only for recognized head

addsec $head,$hdpx,$body if defined $head and defined $body;
# print "$_\n$BODY{$_}" foreach @HEAD; exit 1;

# ------------------------------------------------------------------ SECTIONS TYPES

# list of sections always treated as regular
$REG=<<EOF;
NAME
DESCRIPTION
VERSION
AUTHOR
REPORTING BUGS
COPYRIGHT
SEE ALSO
EOF

# list of sections always treated as preformatted
$PRE=<<EOF;
USAGE
OPTIONS
SYNOPSIS
EXAMPLES
EXAMPLE
EOF

our @REG = split /\n/,$REG;
our @PRE = split /\n/,$PRE;

our %TYPE; # 1=REG 2=PRE
foreach my $h (@HEAD) {
  if(inar \@REG,$h) { $TYPE{$h}=1; } # always regular
  elsif(inar \@PRE,$h) { $TYPE{$h}=2; } # always preformatted
  elsif($BODY{$h}=~/(^|\n)\h*-[a-zA-Z0-9]/) { $TYPE{$h}=2; } # seems, list of options included
  else { $TYPE{$h}=1; }} # default regular
# print "$_ $TYPE{$_}\n" foreach @HEAD;

# -------------------------------------------------------------- INDENTATION PREFIX

my $ind = 1000; # total minimal indentation level
foreach my $h (@HEAD) {
  next if not $TYPE{$h} == 2;
  foreach my $s (split /\n/,$BODY{$h}) {
    next if $s =~ /^\h*$/; # skip empty lines
    if($s =~ /^( *)/) {
      my $len = length $1;
      $ind = $len if $len < $ind; }}}

my $px = ""; # required prefix to maintain minimal indentatiot to be four
for(my $i=0; $i<4-$ind; $i++) { $px.=" "; }
# print "max ind: $ind\n";

# ----------------------------------------------------------------- ASSEMBLE OUTPUT

our $OUT; # output string
foreach my $h (@HEAD) {

  # header
  $OUT .= "$HDPX{$h} $h\n";

  # regular text
  if($TYPE{$h} == 1) {
    my $sp; # indentation space in current regular section input
    foreach my $s (split /\n/,$BODY{$h}) {
      $sp = $1 if not defined $sp and $s=~/^( *)[^ ]/; # only for 1st line
      $s =~ s/^$sp//; # remove indentation here
      $OUT .= "$s\n"; }}
      
  # preformatted text
  elsif($TYPE{$h} == 2) {
    foreach my $s (split /\n/,$BODY{$h}) {
      $OUT .= "$px$s\n"; }}

  $OUT .= "\n"; }

# -------------------------------------------------------------------------- OUTPUT

# add final newline
$OUT .= "\n";

# print output
print "$OUT";

# ---------------------------------------------------------------------------------
